<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>webRTC原理及Android使用WebRTC实现P2P通信 | kdsunset的个人博客</title><meta name="author" content="kdsunset"><meta name="copyright" content="kdsunset"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="webRTC原理及Android使用WebRTC实现P2P通信1 背景在WebRTC（Web Real-Time Communication）出现之前，用户想要实现音视频聊天，流媒体播放等实时通信，需要依赖于专有协议、客户端软件或浏览器插件，例如在浏览器上通过在浏览器上安装Flash插件实现音视频采集和传输，然后用RTMP协议将音视频流传输到服务器中转，再由服务器分发给接收端。这种方式存在延迟较高"><meta property="og:type" content="article"><meta property="og:title" content="webRTC原理及Android使用WebRTC实现P2P通信"><meta property="og:url" content="https://kdsunset.top/webrtc01/index.html"><meta property="og:site_name" content="kdsunset的个人博客"><meta property="og:description" content="webRTC原理及Android使用WebRTC实现P2P通信1 背景在WebRTC（Web Real-Time Communication）出现之前，用户想要实现音视频聊天，流媒体播放等实时通信，需要依赖于专有协议、客户端软件或浏览器插件，例如在浏览器上通过在浏览器上安装Flash插件实现音视频采集和传输，然后用RTMP协议将音视频流传输到服务器中转，再由服务器分发给接收端。这种方式存在延迟较高"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://kdsunset.top/img/avatar.jpg"><meta property="article:published_time" content="2025-04-27T08:54:00.000Z"><meta property="article:modified_time" content="2025-04-27T08:54:00.000Z"><meta property="article:author" content="kdsunset"><meta property="article:tag" content="webrtc"><meta property="article:tag" content="p2p"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://kdsunset.top/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://kdsunset.top/webrtc01/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="oMGwvAFHPDoXj1zawKNDffRQhkEu9BwZwNxguwSOmME"><meta name="baidu-site-verification" content="codeva-AyL3HHSEEb"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?28e4ea7748d7403e4bf35f897a5e67e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":250},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: kdsunset","link":"链接: ","source":"来源: kdsunset的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"webRTC原理及Android使用WebRTC实现P2P通信",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-04-27 16:54:00"}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my_bg_color.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="kdsunset的个人博客" type="application/atom+xml"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/donate/"><i class="fa-fw fas fa-donate"></i> <span>赞赏</span></a></div><div class="menus_item"><a class="site-page" href="/rss/"><i class="fa-fw fas fa-rss"></i> <span>RSS</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/bg_moon.png)"><nav id="nav"><span id="blog-info"><a href="/" title="kdsunset的个人博客"><span class="site-name">kdsunset的个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/donate/"><i class="fa-fw fas fa-donate"></i> <span>赞赏</span></a></div><div class="menus_item"><a class="site-page" href="/rss/"><i class="fa-fw fas fa-rss"></i> <span>RSS</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">webRTC原理及Android使用WebRTC实现P2P通信</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-27T08:54:00.000Z" title="发表于 2025-04-27 16:54:00">2025-04-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-27T08:54:00.000Z" title="更新于 2025-04-27 16:54:00">2025-04-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="webRTC原理及Android使用WebRTC实现P2P通信"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="webRTC原理及Android使用WebRTC实现P2P通信"><a href="#webRTC原理及Android使用WebRTC实现P2P通信" class="headerlink" title="webRTC原理及Android使用WebRTC实现P2P通信"></a>webRTC原理及Android使用WebRTC实现P2P通信</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>在WebRTC（<code>Web Real-Time Communication</code>）出现之前，用户想要实现音视频聊天，流媒体播放等实时通信，需要依赖于专有协议、客户端软件或浏览器插件，例如在浏览器上通过在浏览器上安装Flash插件实现音视频采集和传输，然后用RTMP协议将音视频流传输到服务器中转，再由服务器分发给接收端。这种方式存在延迟较高，且需安装插件，兼容性等问题。</p><p>直到 2011 年，Google 收购了专注音视频处理技术的 GIPS（<code>Global IP Solutions</code>）公司，将其核心技术开源和整合为 WebRTC，并凭借浏览器原生支持（无需插件，自带音视频处理），低延时（P2P点到点通信）等特性，才彻底改变了实时通信的开发方式。</p><p>如今webRTC虽然名字带<code>web</code>，但是早已不仅仅局限于浏览器，已经广泛支持桌面端、移动端甚至物联网设备。</p><h2 id="2-关键概念和原理"><a href="#2-关键概念和原理" class="headerlink" title="2 关键概念和原理"></a>2 关键概念和原理</h2><p>WebRTC是一种支持p2p的实时通信技术，那么什么是P2P？</p><h3 id="2-1-P2P"><a href="#2-1-P2P" class="headerlink" title="2.1 P2P"></a>2.1 P2P</h3><p>传统的中继通信模式中，数据需通过服务器进行转发（如：客户端 A → 中继服务器 → 客户端 B）。这种方式不仅需要部署额外的服务器，而且每一个数据包都必须经过服务器收发，带来高带宽压力，导致延迟增加，成本也随之上升。</p><p>相比之下，后来兴起的 P2P（Peer-to-Peer，点对点）通信模式，数据可以直接在客户端 A 与客户端 B 之间传输，无需经过中转服务器，从而大幅降低延迟，同时节省了服务器部署和带宽成本。</p><p>注意p2p的通讯虽然不通过中转服务器转发媒体流数据，但是仍然需要通过一个服务器转发基础信息。<br>通信大致流程：<br>双方创建音视频设备和连接实例，通过信令交换连接信息，协商通信参数后收集并交换网络地址，完成连通性测试后建立 P2P 连接，开始实时传输数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as 呼叫方（Peer A）</span><br><span class="line">    participant S as 信令服务器</span><br><span class="line">    participant B as 接收方（Peer B）</span><br><span class="line"></span><br><span class="line">    A-&gt;&gt;S: 发起会话请求</span><br><span class="line">    S-&gt;&gt;B: 转发请求</span><br><span class="line">    B-&gt;&gt;S: 发送回应</span><br><span class="line">    S-&gt;&gt;A: 转发回应  </span><br><span class="line">    A--&gt;&gt;B: 建立 P2P 直接,发送音视频数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-信令服务器"><a href="#2-2-信令服务器" class="headerlink" title="2.2 信令服务器"></a>2.2 信令服务器</h3><p>在p2p双方建立直连之前，互相不知道对方的存在，因此就需要一个称为信令服务器的中间人来转达信息，一是可以知道对方存在，而是可以交换信息，信息交换完成后它们才可以互相直接通讯。</p><p>WebRTC并没规定这部分的内容，因此协议、库、语言都是可选的，只要双方能通信、解析信息就可以：</p><ul><li>自定义信令消息格式（通常是 JSON）</li><li>使用任何支持实时通信的协议（如 WebSocket）</li><li>自己定义和实现信令命令</li></ul><p>虽然协议是自定义的，但通常要实现以下几种基础信令命令来协助客户端完成 WebRTC 的连接建立过程：</p><table><thead><tr><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>join &#x2F; login</td><td>客户端加入房间或注册标识</td><td>建立用户身份或房间</td></tr><tr><td>offer</td><td>发送 SDP offer</td><td>发起方发送连接请求</td></tr><tr><td>answer</td><td>回复 SDP answer</td><td>接收方回复连接同意</td></tr><tr><td>candidate</td><td>发送 ICE 候选</td><td>交换 NAT 穿透所需的 ICE 信息</td></tr><tr><td>leave &#x2F; disconnect &#x2F; bye</td><td>退出连接或房间</td><td>用于释放资源或提示对方</td></tr><tr><td>ping &#x2F; pong（可选)</td><td>保活机制</td><td>检测连接存活状态</td></tr></tbody></table><p>p2p通讯过程中需要交换哪些信息？</p><h3 id="2-3-SDP-协商"><a href="#2-3-SDP-协商" class="headerlink" title="2.3 SDP 协商"></a>2.3 SDP 协商</h3><p>SDP（<code>Session Description Protoco</code>）是webrtc中用来描述媒体流信息的协议，比如媒体格式、编解码方式等的一个协议。因为不同设备的媒体参数（分辨率、采样率、比特率、通道数等）和支持的编解码器（如 VP8, H264, Opus 等）可能不尽相同，双方需要协商，采用一个大家都支持或者兼容的参数。</p><p>例如以下是当 A 执行 createOffer() 时生成的 SDP部分内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v=0</span><br><span class="line">o=- 4611733053049959640 2 IN IP4 127.0.0.1</span><br><span class="line">s=-</span><br><span class="line">t=0 0</span><br><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111</span><br><span class="line">a=rtpmap:111 opus/48000/2</span><br><span class="line">a=sendrecv</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当 B 在 setRemoteDescription() 后会根据此 SDP 判断自己是否能接受，如果可以就生成对应 answer SDP，告诉 A：“我接受你的要求，我也支持这些设置”。</p><p>部分SDP 协商包含类型：</p><table><thead><tr><th>目的</th><th>说明</th></tr></thead><tbody><tr><td>媒体类型</td><td>是否使用音频、视频或数据通道</td></tr><tr><td>编解码器</td><td>每种媒体类型支持的编解码器，如 Opus、VP8、H264 等</td></tr><tr><td>媒体参数</td><td>分辨率、采样率、比特率、通道数</td></tr><tr><td>加密方式</td><td>通信的加密协商，比如 DTLS-SRTP 的指纹信息</td></tr></tbody></table><p>此时连接流程图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as Peer A（呼叫方）</span><br><span class="line">    participant S as 信令服务器</span><br><span class="line">    participant B as Peer B（接收方）</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    A-&gt;&gt;S: 发送 Offer SDP</span><br><span class="line">    S-&gt;&gt;B: 转发 Offer SDP</span><br><span class="line">    B-&gt;&gt;S: 发送 Answer SDP</span><br><span class="line">    S-&gt;&gt;A: 转发 Answer SDP</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    A--&gt;&gt;B: 建立 P2P 连接</span><br><span class="line">    A--&gt;&gt;B: 传输音视频流或数据</span><br><span class="line">    B--&gt;&gt;A: 传输音视频流或数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-NAT技术"><a href="#2-4-NAT技术" class="headerlink" title="2.4 NAT技术"></a>2.4 NAT技术</h3><p>以上p2p通信建立过程中如果两个设备都有公网ip地址，那他们可以直接建立连接，但是现实情况是：绝大多数设备都没有自己的公网ip，只能通过路由器等设备共享一个公网地址来与互联网上的其他设备进行连接。</p><p>为什么设备要通过内网地址映射而不能使用公网IP直连呢，因为公网IP不够用。相信很多人都曾听说过IP网地址即将用尽的说法：IPv4是目前广泛使用的 IP 协议， 总共只有 约 43 亿个地址，但是设计者没有预料到互联网发展如此迅速，很快IP地址将不够分配给所有设备。</p><p>为了解决公网 IP 不够的问题，IETF组织提出了私有地址的概念，专门保留了三段 IP 地址给内部网络使用。设备使用私有地址，形成了局域网（LAN），各自局域网的私有地址可以重复利用，于是有效缓解公网地址枯竭的问题。但是私有地址无法直接访问公网，就需要NAT（<code>Network Address Translation</code>）技术桥接，将私有地址转换成公网地址。</p><blockquote><p>私有地址范围：<br>10.0.0.0-10.255.255.255<br>172.16.0.0—172.31.255.255<br>192.168.0.0-192.168.255.255</p></blockquote><p>例如家里的电脑A(假设ip为192.168.1.100)想要访问xx网站（假设地址为104.18.10.232）:</p><ol><li><p>首先电脑A发出的http请求会被路由器（假设地址为203.0.113.5）收到，</p></li><li><p>路由器会将这个TCP&#x2F;IP包的电脑A的地址替换为自己的公网地址并记录下来（NAT表，实际上路由器为了稳定和避免冲突，端口也会被重新分配），再由它向xx网站服务器发出请求，</p></li><li><p>服务器返回信息给路由器，路由器查 NAT 表将回包发给电脑A。</p></li></ol><p>NAT技术有效解决 IPv4 地址紧张的问题，同时也将终端设备与公网隔离，不易被攻击，增加了安全性。不过正是由于内网设备不能直接被公网直接访问，增加了p2p连接的难度。想要打破这层物理障碍，必须进行NAT穿透（俗称打洞）。</p><p><strong>常见穿透方式：</strong></p><table><thead><tr><th>方式</th><th>原理</th></tr></thead><tbody><tr><td>STUN协议</td><td>协助内网设备获取 NAT 后的公网地址和端口</td></tr><tr><td>TURN协议</td><td>通过中继服务器转发数据（穿透失败时兜底方案）</td></tr><tr><td>ICE框架</td><td>综合使用 STUN + TURN，选择最佳路径</td></tr></tbody></table><h3 id="2-5-STUN协议及其服务器"><a href="#2-5-STUN协议及其服务器" class="headerlink" title="2.5 STUN协议及其服务器"></a>2.5 STUN协议及其服务器</h3><p>STUN 是 NAT 穿透的第一步，作用是获取设备在公网的映射地址。它的原理很简单，内网设备向 STUN 服务器发送一个请求（通常是 UDP 协议），服务器记录这个IP和端口并返回响应，内网设备便知道了自己的公网地址（实际上是路由器的公网 IP + 动态端口），后续再发给信令服务器以建立连接。<br>打个比方就是你忘了自己的手机号码，打电话给朋友让他从来电记录里告知你的电话号码。</p><p><strong>NAT 穿透到底穿的是什么？</strong><br>通常只有内网设备发送数据到外部，路由器才创建NAT 映射。公网的外部是不能主动向这个内网设备发起连接的，因为NAT 表里没有记录，就无法找到对应哪个内网设备，此时外部无法连接内网，就仿佛一堵NAT墙。</p><p><strong>为什么不能用信令服务器进行NAT穿透</strong><br>NAT 是基于 协议类型（TCP 或 UDP） 维护映射表的，即使内网设备的本地 IP 和端口是一样的，只要协议类型不同，NAT 会创建两条不同的映射表项。</p><p>信令协议通常使用 TCP 或 WebSocket，因为 TCP 具有较好的可靠性和穿透性，适合用于信令数据的传输。而对于音视频数据，虽然可以使用 TCP，但UDP提供更低的延迟和更好的实时性，即使它会丢包，但不会像 TCP 那样因丢包而阻塞流媒体的传输。</p><p>因此，NAT 穿透通常不适用于信令服务器，因为信令服务器本身并不直接处理音视频数据流的传输，也无法直接穿透 NAT 来建立端到端的 P2P 连接。</p><h3 id="2-6-TURN协议及其服务器"><a href="#2-6-TURN协议及其服务器" class="headerlink" title="2.6 TURN协议及其服务器"></a>2.6 TURN协议及其服务器</h3><p>NAT 有几种类型，如对称型、完全锥型，不同类型穿透难度不同，对称型NAT基本无法穿透。当 NAT 穿透失败时，通信双方恢复到中转通信的模式，TURN 提供一个中继服务器来转发数据，都把数据发到 TURN 服务器，由它进行转发。</p><h3 id="2-7-ICE框架"><a href="#2-7-ICE框架" class="headerlink" title="2.7 ICE框架"></a>2.7 ICE框架</h3><p>除了交换媒体参数，通信双方还需要交互网络信息，才能找到一条相互通讯的链路。</p><p>ICE是WebRTC 中的机制，作用是通过收集候选（Candidate）地址，找出一条最优的网络路径让两个 Peer 能直接通信。</p><p>ICE 中的候选类型：</p><table><thead><tr><th>类型</th><th>描述</th><th>来源</th></tr></thead><tbody><tr><td>Host 候选（本地 IP）</td><td>直接使用本地网络 IP 地址</td><td>设备本地</td></tr><tr><td>Server Reflexive（公网映射 IP）</td><td>通过 STUN 服务器获取的公网地址</td><td>STUN</td></tr><tr><td>Relay (TURN服务器IP)</td><td>通过 TURN 服务器中转的地址</td><td>TURN</td></tr></tbody></table><p>连接时双方收集候选（Candidate）地址，并通过信令服务器互相交换，然后选出连接成功、延迟最低的一组地址作为最终通信路径，具体是：用本地 IP 直连，不行就通过 STUN 获取你们的公网映射 IP 再打洞，还不行就用 TURN 中继来绕过防火墙。</p><h3 id="2-8-关键API"><a href="#2-8-关键API" class="headerlink" title="2.8 关键API"></a>2.8 关键API</h3><table><thead><tr><th>API</th><th>用途说明</th></tr></thead><tbody><tr><td>new RTCPeerConnection()</td><td>创建一个用于 WebRTC 连接的核心对象</td></tr><tr><td>createOffer()</td><td>创建一个包含本地媒体信息的 SDP（会话描述），用于发起连接请求。</td></tr><tr><td>createAnswer()</td><td>基于接收到的 offer 创建一个 SDP 回应</td></tr><tr><td>setLocalDescription()</td><td>设置本地 SDP（发起者），并启动异步 ICE 候选收集过程</td></tr><tr><td>setRemoteDescription()</td><td>设置远端的 answer SDP，完成 SDP 协商流程。</td></tr><tr><td>onicecandidate</td><td>触发事件回调，在收集到一个候选地址（candidate）时被调用。</td></tr><tr><td>addIceCandidate(candidate)</td><td>接收到对方通过信令发送来的 candidate 后，添加到 ICE 引擎中，参与连接测试。</td></tr></tbody></table><p>结合上面的api现在可以整理一份较为完整的流程图，</p><h3 id="2-9-WebRTC-P2P-建立连接时序图"><a href="#2-9-WebRTC-P2P-建立连接时序图" class="headerlink" title="2.9 WebRTC P2P 建立连接时序图"></a>2.9 WebRTC P2P 建立连接时序图</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.kdsunset.top/img/webrtc01webrtc%20p2p%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%8F%E5%9B%BE.png"><br>注意：实际上当一方调用 setLocalDescription() 设置了 offer&#x2F;answer 后，ICE 代理就会开始收集候选地址（如主机地址、STUN 公网地址、TURN 中继地址等），和 SDP 的发送是并行的。<br>它不需要等到 Offer&#x2F;Answer 流程完成才开始发送。每收集一个候选，浏览器会通过 onicecandidate 回调通知应用并通过信令发送给对端，收到对端的候选后添加进连接中，然后双方互测这些地址直至找到最佳路径。</p><p>总结一下，以上流程看似复杂，实则主要做了两件事情，交换SDP信息（媒体协商）和交换ice（网络协商）。</p><p>打个不太准确的比方，信令服务器就像中介&#x2F;媒人，通信过程可以看成相亲过程：</p><p>1小伙子阿强先写下自我介绍我是阿强，我会blabla…（createOffer），保存好（setLocalDescription），然后把资料发给中间人（发送 offer SDP）。<br>2.中间人把资料发给女方，女方收到后，先记下对方资料（setRemoteDescription），然后再整理自己的介绍语我是阿珍blabla（createAnswer）也保存来（setLocalDescription），发给中间人代为转达（ 发送 answer SDP）。<br>3.小伙子收到中间人回信，记下来对方信息（setRemoteDescription）<br>4.双方继续通过中间人交换电话号码&#x2F;住址&#x2F;微信等联系信息，确定如何联系对方之后就可以直接交流。</p><h2 id="3-实现信令服务器及其客户端"><a href="#3-实现信令服务器及其客户端" class="headerlink" title="3 实现信令服务器及其客户端"></a>3 实现信令服务器及其客户端</h2><p>这个例子实现两台Android设备在局域网内的通过WebRTC进行视频通话，不涉及TURN服务器。我们首先看信令服务器：</p><h3 id="3-1-服务端"><a href="#3-1-服务端" class="headerlink" title="3.1 服务端"></a>3.1 服务端</h3><p>信令服务器主要功能是帮助两个客户端交换建立连接所需的信息，<br>这个例子采用Node.js + ws实现，搭建起来比java略快。命令只完成了最基础的3条：发起P2P连接请求(offer)、接受P2P连接请求(answer)、交换ice信息(candidate)。没有区分客户端，接收到命令后转发给其他所有在线的客户端。</p><p><strong>环境搭建</strong><br>Node.js是一个跨平台的 JavaScript 运行时环境, 能够创建服务器 Web 应用。附安装搭建步骤：</p><ol><li>在<a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn">Node.js官网</a>下载Node.js，安装完成可通过<code>node -v</code>和<code>npm -v</code>命令检测是否安装成功，然后新建项目目录并在目录打开命令提示符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建js文件，名字随意，也可以用右键菜单新建文件</span></span><br><span class="line"><span class="built_in">touch</span> server.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 package.json</span></span><br><span class="line">npm init -y     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装ws 模块</span></span><br><span class="line">npm install ws express          </span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>源码</strong><br>以下<code>server.js</code>完整源码：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span> = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 WebSocket 服务器</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接的用户列表（可以用来广播消息给所有连接的客户端）</span></span><br><span class="line"><span class="keyword">let</span> clients = [];</span><br><span class="line"></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每当有客户端连接时，将其添加到客户端列表</span></span><br><span class="line">    clients.<span class="title function_">push</span>(ws);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A new client connected.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理来自客户端的消息</span></span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> text = <span class="keyword">typeof</span> message === <span class="string">&#x27;string&#x27;</span> ? message : message.<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received: %s&#x27;</span>, text);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#x27;</span>);</span><br><span class="line">        <span class="comment">// 可以根据实际情况广播消息，或者发送给特定客户端</span></span><br><span class="line">        <span class="comment">// 在这个例子中，我们将消息广播给所有客户端</span></span><br><span class="line">        clients.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (client !== ws &amp;&amp; client.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">                client.<span class="title function_">send</span>(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端断开连接</span></span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        clients = clients.<span class="title function_">filter</span>(<span class="function"><span class="params">client</span> =&gt;</span> client !== ws);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A client disconnected.&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 HTTP 服务（用于测试接口等）</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;WebSocket signaling server is running!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP server is running on port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行</strong><br>使用以下命令运行代码，正常会输出<code>WebSocket signaling server is running!</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用命令运行代码</span><br><span class="line">node server.js</span><br></pre></td></tr></table></figure><h2 id="4-Aandroid-通过WebRTC实现P2P通信"><a href="#4-Aandroid-通过WebRTC实现P2P通信" class="headerlink" title="4 Aandroid 通过WebRTC实现P2P通信"></a>4 Aandroid 通过WebRTC实现P2P通信</h2><p>webrtc的原生库可以通过<a target="_blank" rel="noopener" href="https://webrtc.googlesource.com/src/+/main/docs/native-code/android/">官网</a>进行编译，也可以使用现成的，<br><strong>添加依赖</strong></p><figure class="highlight kts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webrtc库 可以使用谷歌官方仓库or webrtc-sdk</span></span><br><span class="line"><span class="comment">//implementation(&quot;org.webrtc:google-webrtc:1.0.32006&quot;)</span></span><br><span class="line">implementation(<span class="string">&quot;io.github.webrtc-sdk:android:125.6422.06.1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// okhttp3 用于信令通信</span></span><br><span class="line">implementation(<span class="string">&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-1-UI界面"><a href="#4-1-UI界面" class="headerlink" title="4.1 UI界面"></a>4.1 UI界面</h3><p>我们先来看UI界面，WebRTCUI提供了一个全屏的SurfaceView用于渲染对方的视频画面，左上角一个小localSurfaceView用于展示自己的视频画面，Button用于拨打或者挂断，拨打后对方直接接通。<br></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WebRTCUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isCalling <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webRTCClient:WebRTCClient?=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> context = LocalContext.current</span><br><span class="line">    <span class="comment">// 本地视频显示</span></span><br><span class="line">    <span class="keyword">val</span> localSurfaceView = remember &#123; SurfaceViewRenderer(context) &#125;</span><br><span class="line">    <span class="comment">// 远程视频显示</span></span><br><span class="line">    <span class="keyword">val</span> remoteSurfaceView = remember &#123; SurfaceViewRenderer(context) &#125;</span><br><span class="line">    LaunchedEffect(key1 = <span class="built_in">Unit</span>) &#123;</span><br><span class="line">        webRTCClient = WebRTCClient(context)</span><br><span class="line">        webRTCClient?.setLocalSurfaceView(localSurfaceView)</span><br><span class="line">        webRTCClient?.setRemoteSurfaceView(remoteSurfaceView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Box(modifier = Modifier.fillMaxSize()) &#123;</span><br><span class="line">        AndroidView(</span><br><span class="line">            factory = &#123; remoteSurfaceView &#125;,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                .fillMaxHeight()</span><br><span class="line">        )</span><br><span class="line">        AndroidView(</span><br><span class="line">            factory = &#123; localSurfaceView &#125;,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .width(<span class="number">160.</span>dp).height(<span class="number">240.</span>dp)</span><br><span class="line">                .background(color = Color.Red, shape = RoundedCornerShape(<span class="number">8.</span>dp))</span><br><span class="line">                .align(Alignment.TopEnd)</span><br><span class="line">        )</span><br><span class="line">        Column(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .fillMaxWidth().align(Alignment.BottomCenter)</span><br><span class="line">                .padding(<span class="number">16.</span>dp),</span><br><span class="line">            horizontalAlignment = Alignment.CenterHorizontally,</span><br><span class="line">            verticalArrangement = Arrangement.Center</span><br><span class="line">        ) &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;WebRTC Demo&quot;</span>)</span><br><span class="line">            Spacer(modifier = Modifier.height(<span class="number">16.</span>dp))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动通话按钮</span></span><br><span class="line">            Button(onClick = &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isCalling) &#123;</span><br><span class="line">                    <span class="comment">// 启动视频通话</span></span><br><span class="line">                    webRTCClient?.startPreview()</span><br><span class="line">                    webRTCClient?.startCall()</span><br><span class="line">                    isCalling = <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 结束视频通话</span></span><br><span class="line">                    webRTCClient?.stopPreview()</span><br><span class="line">                    webRTCClient?.endCall()</span><br><span class="line">                    isCalling = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;) &#123;</span><br><span class="line"></span><br><span class="line">                Text(text = <span class="keyword">if</span> (isCalling) <span class="string">&quot;挂断&quot;</span> <span class="keyword">else</span> <span class="string">&quot;拨打&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="4-2-WebRTC组件"><a href="#4-2-WebRTC组件" class="headerlink" title="4.2 WebRTC组件"></a>4.2 WebRTC组件</h3><p><strong>初始化</strong><br>PeerConnectionFactory 是 WebRTC 的核心类之一，它的作用是创建和管理 WebRTC 中涉及的所有媒体组件。在使用 WebRTC 建立音视频通信时，第一步就是初始化 PeerConnectionFactory，之后通过它来创建其他必要组件，包括：</p><ul><li>PeerConnection P2P 连接，用于交换媒体数据</li><li>AudioSource &#x2F; VideoSource 音频&#x2F;视频的数据源</li><li>AudioTrack &#x2F; VideoTrack 音频&#x2F;视频轨道，用于传输<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebRTCClient</span>(<span class="keyword">private</span> <span class="keyword">val</span> context: Context) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 WebRTC </span></span><br><span class="line">        <span class="keyword">val</span> options = PeerConnectionFactory.InitializationOptions.builder(context)</span><br><span class="line">                .createInitializationOptions()</span><br><span class="line">        PeerConnectionFactory.initialize(options)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 EGL 上下文，用于视频处理和渲染</span></span><br><span class="line">        eglBase = EglBase.create()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 PeerConnectionFactory</span></span><br><span class="line">        factory = PeerConnectionFactory.builder()</span><br><span class="line">            .setVideoEncoderFactory(DefaultVideoEncoderFactory(eglBase!!.eglBaseContext, <span class="literal">true</span>, <span class="literal">true</span>))</span><br><span class="line">            .setVideoDecoderFactory(DefaultVideoDecoderFactory(eglBase!!.eglBaseContext))</span><br><span class="line">            .createPeerConnectionFactory()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-视频采集和预览"><a href="#4-3-视频采集和预览" class="headerlink" title="4.3 视频采集和预览"></a>4.3 视频采集和预览</h3><p><strong>SurfaceViewRenderer组件</strong><br>在 Android 下 WebRTC 使用OpenGL ES 进行视频渲染，然后提供的一个用于在 Android 上 渲染视频画面（本地或远端） 的视图组件<code>org.webrtc.SurfaceViewRenderer</code> （继承自SurfaceView）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 远端视频 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">org.webrtc.SurfaceViewRenderer</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/remote_video_view&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 本地视频（画中画） --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">org.webrtc.SurfaceViewRenderer</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/local_video_view&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_gravity</span>=<span class="string">&quot;top|end&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>或者compose中</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地视频显示</span></span><br><span class="line"><span class="keyword">val</span> localSurfaceView = remember &#123; SurfaceViewRenderer(context) &#125;</span><br><span class="line"><span class="comment">// 远程视频显示</span></span><br><span class="line"><span class="keyword">val</span> remoteSurfaceView = remember &#123; SurfaceViewRenderer(context) &#125;</span><br><span class="line"></span><br><span class="line">Box(modifier = Modifier.fillMaxSize()) &#123;</span><br><span class="line">    AndroidView(</span><br><span class="line">        factory = &#123; remoteSurfaceView &#125;,</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .fillMaxHeight()</span><br><span class="line">    )</span><br><span class="line">    AndroidView(</span><br><span class="line">        factory = &#123; localSurfaceView &#125;,</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .width(<span class="number">160.</span>dp).height(<span class="number">240.</span>dp)</span><br><span class="line">            .background(color = Color.Red, shape = RoundedCornerShape(<span class="number">8.</span>dp))</span><br><span class="line">            .align(Alignment.TopEnd)</span><br><span class="line">    )</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>初始化SurfaceViewRenderer，本地和远端的初始化参数基本相同</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setLocalSurfaceView</span><span class="params">(surfaceView: <span class="type">SurfaceViewRenderer</span>)</span></span> &#123;</span><br><span class="line">    localSurfaceView = surfaceView</span><br><span class="line">    localSurfaceView?.apply &#123;</span><br><span class="line">        <span class="comment">// 初始化渲染器，必须传入 EGL 上下文</span></span><br><span class="line">        <span class="keyword">init</span>(eglBase!!.eglBaseContext, <span class="literal">null</span>)</span><br><span class="line">        setZOrderMediaOverlay(<span class="literal">true</span>) <span class="comment">// 设置为覆盖层（在其他 UI 上层）</span></span><br><span class="line">        setEnableHardwareScaler(<span class="literal">true</span>) <span class="comment">// 启用硬件缩放</span></span><br><span class="line">        setScalingType(RendererCommon.ScalingType.SCALE_ASPECT_FILL) <span class="comment">// 保持比例填充</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>摄像头采集</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建摄像头捕获器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createCameraCapture</span><span class="params">(usingFront: <span class="type">Boolean</span>)</span></span>: VideoCapturer? &#123;</span><br><span class="line">    <span class="comment">// 使用 Camera2 API 枚举摄像头</span></span><br><span class="line">    <span class="keyword">val</span> enumerator = Camera2Enumerator(context)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历设备列表</span></span><br><span class="line">    <span class="keyword">for</span> (deviceName <span class="keyword">in</span> enumerator.deviceNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (usingFront &amp;&amp; enumerator.isFrontFacing(deviceName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> enumerator.createCapturer(deviceName, <span class="literal">null</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!usingFront &amp;&amp; enumerator.isBackFacing(deviceName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> enumerator.createCapturer(deviceName, <span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 没找到合适的摄像头</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>创建本地音视频流实现预览</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">startPreview</span><span class="params">(usingFrontCamera: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localVideoTrack != <span class="literal">null</span>) <span class="keyword">return</span> <span class="comment">// 避免重复初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 创建本地音频源和音频轨道</span></span><br><span class="line">    <span class="keyword">val</span> audioSource = factory?.createAudioSource(MediaConstraints())</span><br><span class="line">    localAudioTrack = factory?.createAudioTrack(<span class="string">&quot;101&quot;</span>, audioSource!!)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建摄像头捕获器</span></span><br><span class="line">    videoCapture = createCameraCapture(usingFrontCamera)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 创建视频源和视频轨道</span></span><br><span class="line">    <span class="keyword">val</span> videoSource = factory?.createVideoSource(videoCapture!!.isScreencast)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建纹理处理线程（SurfaceTextureHelper）并初始化捕获器</span></span><br><span class="line">    surfaceTextureHelper = SurfaceTextureHelper.create(<span class="string">&quot;CaptureThread&quot;</span>, eglBase!!.eglBaseContext)</span><br><span class="line">    videoCapture?.initialize(surfaceTextureHelper, context, videoSource?.capturerObserver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动视频捕获（分辨率：1280x720，帧率：30）</span></span><br><span class="line">    videoCapture?.startCapture(<span class="number">1280</span>, <span class="number">720</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建视频轨道（trackId 随便起名）</span></span><br><span class="line">    localVideoTrack = factory?.createVideoTrack(<span class="string">&quot;100&quot;</span>, videoSource!!)</span><br><span class="line">    <span class="comment">// 绑定到 SurfaceViewRenderer</span></span><br><span class="line">    localVideoTrack?.addSink(localSurfaceView)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-4-创建及初始化-PeerConnection-对象"><a href="#4-4-创建及初始化-PeerConnection-对象" class="headerlink" title="4.4 创建及初始化 PeerConnection 对象"></a>4.4 创建及初始化 PeerConnection 对象</h3><p>呼叫方点击拨打按钮，创建PeerConnection连接并进行初始。</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">startCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    initPeerConnectionForCallee()</span><br><span class="line">    sendOffer()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initPeerConnectionForCallee</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> iceServers = listOf(</span><br><span class="line">        PeerConnection.IceServer.builder(<span class="string">&quot;stun:stun.l.google.com:19302&quot;</span>).createIceServer()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 这里STUN/TURN根据实际中需要设置</span></span><br><span class="line">    <span class="comment">// val rtcConfig = PeerConnection.RTCConfiguration(iceServers) </span></span><br><span class="line">    <span class="keyword">val</span> rtcConfig = PeerConnection.RTCConfiguration(emptyList())</span><br><span class="line">    <span class="comment">// 创建 PeerConnection，并注册监听器（Observer）</span></span><br><span class="line">    peerConnection = factory?.createPeerConnection(rtcConfig, <span class="keyword">object</span> : PeerConnection.Observer &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onIceCandidate</span><span class="params">(candidate: <span class="type">IceCandidate</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 当生成新的 ICE 候选时，调用 onIceCandidate 方法并发送到信令服务器</span></span><br><span class="line">            signalingClient.sendIceCandidate(candidate)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他回调...</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加音视频轨道到 PeerConnection</span></span><br><span class="line">    peerConnection?.addTrack(localVideoTrack) <span class="comment">// 添加视频轨道</span></span><br><span class="line">    peerConnection?.addTrack(localAudioTrack) <span class="comment">// 添加音频轨道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建呼叫方 SDP Offer（本地描述），创建成功后，设置本地sdp，并通过信令服务器发送给接收方。<br><strong>发送Offer</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendOffer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sdpConstraints = MediaConstraints()</span><br><span class="line">    peerConnection?.createOffer(<span class="keyword">object</span> : SdpObserver &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateSuccess</span><span class="params">(sdp: <span class="type">SessionDescription</span>?)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 设置本地 SDP</span></span><br><span class="line">            peerConnection?.setLocalDescription(createSdpObserver(<span class="string">&quot;呼叫方：设置LocalDescription&quot;</span>), sdp)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 offer SDP 发送给远端用户</span></span><br><span class="line">            signalingClient.sendOffer(offer = sdp?.description ?: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;, sdpConstraints)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-交换SDP和ICE信息"><a href="#4-5-交换SDP和ICE信息" class="headerlink" title="4.5 交换SDP和ICE信息"></a>4.5 交换SDP和ICE信息</h3><p><strong>连接信令服务器</strong><br>这一步应在WebRTCClient初始化一同完成</p><p><strong>呼叫方收到Offer命令</strong><br>当呼叫方建立连接并通过<code>sendOffer</code>方法获取自己的SDP信息并通过信令服务器客户端SignalingClient发送命令，信令服务器收到后转发给接收方，接受方的SignalingClient监听到服务器发过来的<code>offer</code>命令，回调<code>onOfferReceived</code>方法，即此时接受方收到“来电提醒”，，可以选择接听或者拒绝，这里为了演示简便自动连接，启动预览、创建连接和发送anser SDP信息。</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> :SignalingListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOfferReceived</span><span class="params">(offer: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 2 接收方：收到呼叫方步骤1的Offer，记录下来，然后创建自己的 SDP Answer 并发送</span></span><br><span class="line">        startPreview()</span><br><span class="line">        initPeerConnectionForCallee()</span><br><span class="line">        sendAnswer(remoteOffer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendAnswer</span><span class="params">(remoteOffer:<span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> remoteSdp = SessionDescription(SessionDescription.Type.OFFER, remoteOffer)</span><br><span class="line">    peerConnection?.setRemoteDescription(createSdpObserver(), remoteSdp)</span><br><span class="line">    <span class="keyword">val</span> sdpConstraints = MediaConstraints()</span><br><span class="line">    peerConnection?.createAnswer(<span class="keyword">object</span> :SdpObserver&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateSuccess</span><span class="params">(sdp: <span class="type">SessionDescription</span>?)</span></span> &#123;</span><br><span class="line">            peerConnection?.setLocalDescription(createSdpObserver(), sdp)</span><br><span class="line">            <span class="comment">// 将 Answer SDP 发送给发送方</span></span><br><span class="line">            signalingClient.sendAnswer(sdp?.description ?: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;,sdpConstraints)</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure><p><strong>呼叫方收到Answer</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnswerReceived</span><span class="params">(answer: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 3 呼叫方：收到接收方的SDP Answer，记录(设置)下来</span></span><br><span class="line">    <span class="keyword">val</span> sessionDescription = SessionDescription(SessionDescription.Type.ANSWER, answer)</span><br><span class="line">    peerConnection?.setRemoteDescription(createSdpObserver(<span class="string">&quot;呼叫方：设置RemoteDescription&quot;</span>), sessionDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加ICE候选地址</strong><br>此过程也会通信进行ICE候选，可能会执行数次，直接连接成功建立或失败。</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onIceCandidateReceived</span><span class="params">(candidate: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将远端的 ICE 候选添加到本地 PeerConnection</span></span><br><span class="line">    <span class="keyword">val</span> jsonObject = JSONObject(candidate)</span><br><span class="line">    <span class="keyword">val</span> sdpMid = jsonObject.getString(<span class="string">&quot;sdpMid&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sdpMLineIndex = jsonObject.getInt(<span class="string">&quot;sdpMLineIndex&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sdp = jsonObject.getString(<span class="string">&quot;sdp&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> iceCandidate = IceCandidate(sdpMid, sdpMLineIndex, sdp)</span><br><span class="line">    peerConnection?.addIceCandidate(iceCandidate)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-6-传输数据和视频渲染"><a href="#4-6-传输数据和视频渲染" class="headerlink" title="4.6 传输数据和视频渲染"></a>4.6 传输数据和视频渲染</h3><p>当连接成功，会在初始化PeerConnection时的PeerConnection.Observer监听到状态。然后则可以在<br>onTrack回调中获得对端的数据，将它与<code>SurfaceViewRenderer</code>绑定，即可获得对方的视频画面。</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onIceConnectionChange</span><span class="params">(newState: <span class="type">PeerConnection</span>.<span class="type">IceConnectionState</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (newState) &#123;</span><br><span class="line">        PeerConnection.IceConnectionState.CONNECTED -&gt; Logcat.d(TAG, <span class="string">&quot;Ice Connected&quot;</span>)</span><br><span class="line">        PeerConnection.IceConnectionState.FAILED -&gt; Logcat.e(TAG, <span class="string">&quot;Ice Connection failed&quot;</span>)</span><br><span class="line">        <span class="comment">// 处理其他状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// peerConnection.addTrack对应onTrack， peerConnection.addStream 对应 onAddStream</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTrack</span><span class="params">(transceiver: <span class="type">RtpTransceiver</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onTrack(transceiver)</span><br><span class="line">    <span class="keyword">val</span> receiver = transceiver?.receiver</span><br><span class="line">    <span class="keyword">val</span> track = receiver?.track()</span><br><span class="line">    <span class="keyword">if</span> (track <span class="keyword">is</span> VideoTrack) &#123;</span><br><span class="line">        track.addSink(remoteSurfaceView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-结束通话释放资源"><a href="#4-7-结束通话释放资源" class="headerlink" title="4.7 结束通话释放资源"></a>4.7 结束通话释放资源</h3><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stopPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 停止捕获摄像头</span></span><br><span class="line">        videoCapture?.stopCapture()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    videoCapture?.dispose()</span><br><span class="line">    surfaceTextureHelper?.dispose()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消预览绑定</span></span><br><span class="line">    localVideoTrack?.removeSink(localSurfaceView)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">endCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    peerConnection?.close()</span><br><span class="line">    peerConnection = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，完成一个视频通话的预览、p2p连接，数据传输的简单例子，进一步的优化可以增加客户端标识，拨打给指定的接受方而不是广播给所有人；增加拒绝或挂断信令，主动通知对方通话结束等等。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>WebRTC以其标准化API、低延迟和免费开源的特点被作为成熟的P2P通信方案采用，但是WebRTC也不是万能的，NAT穿越复杂，穿越失败需要依赖TURN服务器，增加维护成本。另外用户连接数较多时，WebRTC 的点对点（P2P）架构会面临性能瓶颈。是否适宜使用WebRTC，取决于所采用的架构方式（Mesh&#x2F;SFU&#x2F;MCU）和会议规模。<br>本文通过直白的语言讲述了WebRTC的信令交换、SDP 协商、NAT 穿透等概念，并演示了在Android平台上的视频通话例子。</p><p>完整源码已上传到<a target="_blank" rel="noopener" href="https://github.com/kdsunset/webrtcdemo">GitHub</a>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/rajan/p/12308547.html">webrtc的历史和现状</a><br>[2] <a target="_blank" rel="noopener" href="http://www.52im.net/forum.php?mod=viewthread&tid=3680&highlight=webrtc">零基础入门：基于开源WebRTC，从0到1实现实时音视频聊天功能</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://kdsunset.top">kdsunset</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://kdsunset.top/webrtc01/">https://kdsunset.top/webrtc01/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kdsunset.top" target="_blank">kdsunset的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/webrtc/">webrtc</a><a class="post-meta__tags" href="/tags/p2p/">p2p</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/drives01/" title="Linux驱动基础——基于 goldfish 内核的驱动开发与测试"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux驱动基础——基于 goldfish 内核的驱动开发与测试</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">kdsunset</div><div class="author-info__description">kdsunset的个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kdsunset"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#webRTC%E5%8E%9F%E7%90%86%E5%8F%8AAndroid%E4%BD%BF%E7%94%A8WebRTC%E5%AE%9E%E7%8E%B0P2P%E9%80%9A%E4%BF%A1"><span class="toc-text">webRTC原理及Android使用WebRTC实现P2P通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%83%8C%E6%99%AF"><span class="toc-text">1 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">2 关键概念和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-P2P"><span class="toc-text">2.1 P2P</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BF%A1%E4%BB%A4%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">2.2 信令服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-SDP-%E5%8D%8F%E5%95%86"><span class="toc-text">2.3 SDP 协商</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-NAT%E6%8A%80%E6%9C%AF"><span class="toc-text">2.4 NAT技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-STUN%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">2.5 STUN协议及其服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-TURN%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">2.6 TURN协议及其服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-ICE%E6%A1%86%E6%9E%B6"><span class="toc-text">2.7 ICE框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E5%85%B3%E9%94%AEAPI"><span class="toc-text">2.8 关键API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-WebRTC-P2P-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-text">2.9 WebRTC P2P 建立连接时序图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BF%A1%E4%BB%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E5%85%B6%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">3 实现信令服务器及其客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">3.1 服务端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Aandroid-%E9%80%9A%E8%BF%87WebRTC%E5%AE%9E%E7%8E%B0P2P%E9%80%9A%E4%BF%A1"><span class="toc-text">4 Aandroid 通过WebRTC实现P2P通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-UI%E7%95%8C%E9%9D%A2"><span class="toc-text">4.1 UI界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-WebRTC%E7%BB%84%E4%BB%B6"><span class="toc-text">4.2 WebRTC组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%A7%86%E9%A2%91%E9%87%87%E9%9B%86%E5%92%8C%E9%A2%84%E8%A7%88"><span class="toc-text">4.3 视频采集和预览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96-PeerConnection-%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.4 创建及初始化 PeerConnection 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E4%BA%A4%E6%8D%A2SDP%E5%92%8CICE%E4%BF%A1%E6%81%AF"><span class="toc-text">4.5 交换SDP和ICE信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93"><span class="toc-text">4.6 传输数据和视频渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E7%BB%93%E6%9D%9F%E9%80%9A%E8%AF%9D%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-text">4.7 结束通话释放资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/webrtc01/" title="webRTC原理及Android使用WebRTC实现P2P通信">webRTC原理及Android使用WebRTC实现P2P通信</a><time datetime="2025-04-27T08:54:00.000Z" title="发表于 2025-04-27 16:54:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/drives01/" title="Linux驱动基础——基于 goldfish 内核的驱动开发与测试">Linux驱动基础——基于 goldfish 内核的驱动开发与测试</a><time datetime="2025-04-23T01:30:00.000Z" title="发表于 2025-04-23 09:30:00">2025-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/zd6207fq/" title="Ubuntu 下编译goldfish内核并使用模拟器运行">Ubuntu 下编译goldfish内核并使用模拟器运行</a><time datetime="2025-04-06T09:35:00.000Z" title="发表于 2025-04-06 17:35:00">2025-04-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/u8wwtapk/" title="使用apktool实现一个apk修改和打包脚本">使用apktool实现一个apk修改和打包脚本</a><time datetime="2024-08-22T08:22:00.000Z" title="发表于 2024-08-22 16:22:00">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/lireofad/" title="Ubuntu 下编译LibreOffice Android版">Ubuntu 下编译LibreOffice Android版</a><time datetime="2024-04-15T02:35:00.000Z" title="发表于 2024-04-15 10:35:00">2024-04-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/bg_moon.png)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By kdsunset</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2wvhFjzp3cI1Jo1r0kGvI0PA-MdYXbMMI',
      appKey: 'jqpcAA3JdCnCM8NVPMY4nrOR',
      avatar: 'monsterid',
      serverURLs: 'https://api.kdsunset.top',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: '87bca2541154998d9e5d',
      clientSecret: 'b1b448a15758ff09af4f4810c6a66d479d01e00d',
      repo: 'kdsunset.github.io',
      owner: 'kdsunset',
      admin: ['kdsunset'],
      id: '613bcb60fdd238094cccf7da6b1fd639',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Valine' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="//github.elemecdn.com/leancloud-storage@3/dist/av-min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>